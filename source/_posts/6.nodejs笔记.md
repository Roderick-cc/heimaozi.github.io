---
title: Node note
date: 2018-07-15 11:31:01
comments: true
reward: true
toc: true
tags:
	- note
	- node
---





## 知识点

<!-- more-->

- 增删改查
- 登陆
- 注册
- 头像
  + 服务端图片
  + 水印
  + 图片水印
- 找回密码
- 密码修改

- 模块系统
  + 核心模块
  + 第三方模块
  + 自己写的模块载规则以及加载机制
  + 循环加载
- npm
- package.json
- Express
  + 第三方 Web 开发框架
  + 高度封装了 http 模块
  + 更加专注于业务，而非底层细节
  + 知其所以然
- 增删改查
  + 使用文件来保存数据（锻炼异步编码）
- MongoDB
  + （所有方法都封装好了）


- 网站开发模型
  + 黑盒子、哑巴
  + 写代码让它变得更智能
  + 按照你设计好的套路供用户使用

- 在 Node 中使用 art-template 模板引擎
  + 安装
  + 加载
  + template.render()
- 客户端渲染和服务端渲染的区别
  + 最少两次请求，发起 ajax 在客户端使用模板引擎渲染
  + 客户端拿到的就是服务端已经渲染好的
- 处理留言本案例首页数据列表渲染展示
- 处理留言本案例发表留言功能
  + 路径
  + 设计好的请求路径
  + $GET 直接或查询字符串数据
  + Node 中需要咱们自己动手来解析
    * url.parse()
  + /pinglun?name=jack&message=hello
  + split('?')
  + name=jack&message=hello
  + split('&')
  + name=jack message=hello
  + forEach()
  + name=jack.split('=')
  + 0 key
  + 1 value
- 掌握如何解析请求路径中的查询字符串
  + url.parse()
- 如何在 Node 中实现服务器重定向
  + header('location')
    * 301 永久重定向 浏览器会记住
      - a.com b.com
      - a 浏览器不会请求 a 了
      - 直接去跳到 b 了
    * 302 临时重定向 浏览器不记忆
      - a.com b.com
      - a.com 还会请求 a
      - a 告诉浏览器你往 b
- Node 中的 Console（REPL）使用

## 总结

- jQuery 的 each 和 原生的 JavaScript 方法 forEach
  + EcmaScript 5 提供的
    * 不兼容 IE 8
  + jQuery 的 each 由 jQuery 这个第三方库提供
    * jQuery 2 以下的版本是兼容 IE 8 的
    * 它的 each 方法主要用来遍历 jQuery 实例对象（伪数组）
    * 同时它也可以作为低版本浏览器中 forEach 替代品
    * jQuery 的实例对象不能使用 forEach 方法，如果想要使用必须转为数组才可以使用
    * `[].slice.call(jQuery实例对象)`
- 模块中导出多个成员和导出单个成员
- 301 和 302 状态码区别
  + 301 永久重定向，浏览器会记住
  + 302 临时重定向
- exports 和 module.exports 的区别
  + 每个模块中都有一个 module 对象
  + module 对象中有一个 exports 对象
  + 我们可以把需要导出的成员都挂载到 module.exports 接口对象中
  + 也就是：`moudle.exports.xxx = xxx` 的方式
  + 但是每次都 `moudle.exports.xxx = xxx` 很麻烦，点儿的太多了
  + 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：`exports`
  + `exports === module.exports` 结果为  `true`s
  + 所以对于：`moudle.exports.xxx = xxx` 的方式 完全可以：`expots.xxx = xxx`
  + 当一个模块需要导出单个成员的时候，这个时候必须使用：`module.exports = xxx` 的方式
  + 不要使用 `exports = xxx` 不管用
  + 因为每个模块最终向外 `return` 的是 `module.exports`
  + 而 `exports` 只是 `module.exports` 的一个引用
  + 所以即便你为 `exports = xx` 重新赋值，也不会影响 `module.exports`
  + 但是有一种赋值方式比较特殊：`exports = module.exports` 这个用来重新建立引用关系的
  + 之所以让大家明白这个道理，是希望可以更灵活的去用它
- Node 是一个比肩 Java、PHP 的一个平台
  + JavaScript 既能写前端也能写服务端

```javascript
moudle.exports = {
  a: 123
}

// 重新建立 exports 和 module.exports 之间的引用关系
exports = module.exports

exports.foo = 'bar'
```

```javascript
Array.prototype.mySlice = function () {
  var start = 0
  var end = this.length
  if (arguments.length === 1) {
    start = arguments[0]
  } else if (arguments.length === 2) {
    start = arguments[0]
    end = arguments[1]
  }
  var tmp = []
  for (var i = start; i < end; i++) {
    // fakeArr[0]
    // fakeArr[1]
    // fakeArr[2]
    tmp.push(this[i])
  }
  return tmp
}

var fakeArr = {
  0: 'abc',
  1: 'efg',
  2: 'haha',
  length: 3
}

// 所以你就得到了真正的数组。 
[].mySlice.call(fakeArr)
```



- jQuery 的 each 和 原生的 JavaScript 方法 forEach
- 301 和 302 的区别
- 模块中导出单个成员和导出多个成员的方式
- module.exports 和 exports 的区别
- require 方法加载规则
  + 优先从缓存加载
  + 核心模块
  + 路径形式的模块
  + 第三方模块
    * node_modules
- package.json 包描述文件
  + dependencies 选项的作用
- npm 常用命令
- Express 基本使用

- 使用 Express 把之前的留言本案例自己动手改造一下

通过淘宝镜像install page 

```shell
 #设置此命令之后npn install 默认从淘宝的服务器download page
 npm config set registry https://registry.npm.taobao.org
 # 查看 npm 配置信息
 npm config list
```



## 7.Express

### 文件操作路径和模块路径

 文件操作中的相对路径可以省略` ./`，在模块加载中，相对路径中的` ./` 不能省略

```
 在文件操作的相对路径中
    ./data/a.txt 相对于当前目录
    data/a.txt   相对于当前目录
    /data/a.txt  绝对路径，当前文件模块所处磁盘根目录
    c:/xx/xx...  绝对路径
 fs.readFile('./data/a.txt', function (err, data) {
   if (err) {
     console.log(err)
     return console.log('读取失败')
   }
   console.log(data.toString())
 })
```

模块操作路径

```
// 这里如果忽略了 . 则也是磁盘根目录
require('/data/foo.js')
//相对路径
require('./data/foo.js')
//模块加载的路径中的相对路径不能省略 ./
```

### 7.1 demo

#### 7.1.1安装：

```
npm install --save express
```

#### 7.1.2 Hello world

```shell
const rxpress =require('express')
const app = express()

app.get('/',(req,res) => res.send('hello world'))
app.listen(3000,()=>consoel.log('Example app listening'))
```

#### 7.1.3基本路由

get 

```javascript
app.get('/',function(req,res){
  res.sed('hello world')
})
```

post:

```javascript
app.post('/',function(req,res){
  res.send('got a post request')
})
```

#### 7.1.4静态服务-向外开放

```java
app.use(express.static('public'))
 //给public定义了别名
app.use('/static',express.static('public'))

app.use('/static',express.static(path.join(__dirname,'public')))
```

### 7.2 Express

#### 7.2.1 在Express中使用art-template模板引擎

安装

```shell
npm install –save express
npm install --save art-template
npm install --save express-art-template
```

配置：默认的是在views中查找后缀为art的文件

```shell
app.engine('art',require('express-art-template'))
```

使用

```javascript
app.get('/',function (req , res){
  //express 默认回去项目中的view目录中查找index.html
 res.render('index.html',{
   title：'hellow'
 })
  
})
```

如果修改默认的`views`视图渲染存储目录，可以：

```JavaScript
//注意：第一个参数views千万不要写错
app.set('views',目录路径）
```

#### 7.2.2获取post请求参数

get请求数据是在URL通过传输的， req.query能够获取数据，而post请求方式数据是在from-date中，所以通过中间键middleware:

安装：

```javascript
npm install body-parser
```

配置：

```JavaScript
var express = require('express')
var bodyParser = require('body-parser')

var app = express()

// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

app.use(function (req, res) {
  res.setHeader('Content-Type', 'text/plain')
  res.write('you posted:\n')
  res.end(JSON.stringify(req.body, null, 2))
})
```

使用：

```javascript
app.use(function(req,res){
  res.setHeader('Content-type','text/plain')
 //可以通过req.body 来获取表单POST请求体数据
  res.end(JSON.stringify(req.body,null,2))
})
```



#### 7.2.3 获取GET请求参数

Express 内置了一个API，可以直接通过`req.query`获取

```javascript
req.query
```

#### 7.2.4 从文件中读取数据

```javascript
//第二个参数为可选，把读取到的文件直接转换为设定的编码格式
fs.readFile('./date.json','utf8',function(err,date){
  
})
//读取的json文件是字符串类型,需要转换为对象，而对象内的属性是数组才能渲染
res.render() 

```

#### 7.2.5 nodejs 案例

##### 1.起步

##### 2.路由设计 --路由模块提取

```javascript
//1.router 请求另外一个页面
var router = require(./require)
 route（app）
/--->另外的页面
module.exports = function (app){
  app.get()
  ...
}
```

Express提供了一种专门用来包装路由的方式

```javascript
//app.js router.js studuent.js
//--->router.js
var express = require('express')
// 1. 创建一个路由容器
var router = express.Router()
// 2. 把路由都挂载到 router 路由容器中
router.get('/', function (req, res) {})
router.post('/s', function (req, res) {})
// 3. 把 router 导出
module.exports = router

//app.js
//把路由容器挂载到app 服务中
app.use(router)

```





##### 3.提取路由模块

##### 4.设计操作数据的API文件模块



#### 7.2.5 封装异步的API

JavaScript是单线程运行的，程序自上而下执行，单执行到比如定时器并不会执行定时器函数内的程序，而是将放到一边，将文件加载完成，再回到检查执行等待的函数。

如果需要获取一个函数中异步操作的结果，则必须通过回调函数来获取

```javascript
function fu (){
  //异步eg1
//  var date ='默认数据'
//  setTimeout（function(){
//    date = 'hello'
//  },1000）
//  return date 
  //异步eg2
//	  setTimeout（function(){
//    date = 'hello'
  	  return date
//  },1000）
  
}
fn()
------------通过回调--------
函数作为参数在另外一个函数中执行
fn(function (date){
  console.log(data)
})

```

#### sublime自动化格式插件

HTML-CSS-JS prettify

### 修改完代码自动重启服务器

使用第三方命名导航工具来解决频繁修改代码重启服务器：`nodemon`

`nodemon`是一基于Node.js开发的第一第三方命令行工具，我们使用的时候需要独立安装：

```
npm install --global nodemon
```

使用

```
node app.js
#使用
nodemon app.js
```

只要通过nodemon app.js启动的服务，则它会监视你的文件变化，当文件发生改变的时候，会自动帮你重启服务器

## 7.3 封装异步API

基于原生XMLHTTPRequest 封装get方法。ajax

```javascript
function get (url , callback){
  var oReq = new XMLHttpRequest()
  //当请求加载成功之后要调用指定的函数
  oReq.onload = function (){
   //现在需要的到这里的 oReq.responseText
    callback(oReq.responseText)
  }
  oReq.open('get',url ,true)
  oReq.send()
}
get('date.json',function (date){
  console.log(date)
})

```





## 7.4 mongo DB 数据库

32位下载地址[www.mongodb.prg/dl/win32/i386]()

配置环境变量至bin目录

cmd 查看配置是否成功  `mongod --version`

### 启动和关闭MongoDB：

```javascript
//mongod 默认使用执行 mongo 命令所在盘符根目录下的 /date/db 作为自己的数据存储目录
//所以在第一次执行该命令之前先自己手动新建一个 /date/db file
mongod

结束DB进程
ctrl+c
```

如果想要想要修改默认的数据存储目录，可以：

```javascript
mongod --dbpath=数据存储目录路径
```

链接数据库

打开新cmd 执行 mongo

### 基本命令

```javascript
show dbs 查看显示所有数据库
db   --->查看当前的操作的数据库
```

```javascript
use 数据库名称
	切换到指定的数据库（没有则会新建）
show collections  -->显示当前操作的数据库的集合(如输出man1)
db.man1.find()  -->输出集合中的所有数据
```

### 在NOde中操作MongoDB

使用第三方的`mongoose`包来操作

+ 官方[http://mongoosejs.com](mongoosejs.com)
+ 官方指南：[http://mongoosejs.com/docs/guide.html]()
+ 官方API： [http://mongoosejs.com/docs/spi.html]()

install

```shell
npm install --save mongoose
```

### 基本概念

+ 可以有多个数据库
+ 一个数据库可以有多个集合（表）
+ 一个集合中可以有多个文档
+ MongoDB非常灵活，不需要像MySQ 一样先创建数据库、表、设计表结构
  + 当你需要插入数据的时候，只需要指定往哪个数据库的哪个操作就行了
  + 一切都有MongoDB来帮你自动完成建库建表

MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了

Mongoose 这个包就可以让你的设计编写的过程简单化

### 起步

```javascript
var mongoose = require('mongoose')

var Schema = mongoose.Schema

// 1. 连接数据库
// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来
mongoose.connect('mongodb://localhost/itcast')

// 2. 设计文档结构（表结构）
// 字段名称就是表结构中的属性名称
// 约束的目的是为了保证数据的完整性，不要有脏数据
var userSchema = new Schema({
  username: {
    type: String,
    required: true // 必须有
  },
  password: {
    type: String,
    required: true
  },
  email: {
    type: String
  }
})
// 3. 将文档结构发布为模型
//    mongoose.model 方法就是用来将一个架构发布为 model
//    第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称
//                 mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称
//                 例如这里的 User 最终会变为 users 集合名称
//    第二个参数：架构 Schema
//   
//    返回值：模型构造函数
var User = mongoose.model('User', userSchema)
```

### 增删查改

```javascript
// 4. 当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查）
// **********************
// #region /新增数据
// **********************
// var admin = new User({
//   username: 'zs',
//   password: '123456',
//   email: 'admin@admin.com'
// })

// admin.save(function (err, ret) {
//   if (err) {
//     console.log('保存失败')
//   } else {
//     console.log('保存成功')
//     console.log(ret)
//   }
// })
// **********************
// #endregion /新增数据
// **********************




// **********************
// #region /查询数据
// **********************
// User.find(function (err, ret) {
//   if (err) {
//     console.log('查询失败')
//   } else {
//     console.log(ret)
//   }
// })
//得出的是一个数组
// User.find({
//   username: 'zs'
// }, function (err, ret) {
//   if (err) {
//     console.log('查询失败')
//   } else {
//     console.log(ret)
//   }
// })

//得出的是一个对象
// User.findOne({
//   username: 'zs'
// }, function (err, ret) {
//   if (err) {
//     console.log('查询失败')
//   } else {
//     console.log(ret)
//   }
// })
// **********************
// #endregion /查询数据
// **********************



// **********************
// #region /删除数据
// **********************
// User.remove({
//   username: 'zs'
// }, function (err, ret) {
//   if (err) {
//     console.log('删除失败')
//   } else {
//     console.log('删除成功')
//     console.log(ret)
//   }
// })
// **********************
// #endregion /删除数据
// **********************


// **********************
// #region /更新数据
// **********************
// User.findByIdAndUpdate('5a001b23d219eb00c8581184', {
//   password: '123'
// }, function (err, ret) {
//   if (err) {
//     console.log('更新失败')
//   } else {
//     console.log('更新成功')
//   }
// })
// **********************
// #endregion /更新数据
// **********************

```



## 7.5javascript 模块化

Node 中的CommonJS

+ 浏览器中的
  + AMD require.js
  + CMD sea.js
+ ECMAScript 官方规定  ESC6 

## 7.6 Promise

异步编程

### callback hell  : 回调地域

```javascript
var fs = require('fs')

fs.readFile('./data/a.txt', 'utf8', function (err, data) {
  if (err) {
    // return console.log('读取失败')
    // 抛出异常
    //    1. 阻止程序的执行
    //    2. 把错误消息打印到控制台
    throw err
  }
  console.log(data)
  fs.readFile('./data/b.txt', 'utf8', function (err, data) {
    if (err) {
      // return console.log('读取失败')
      // 抛出异常
      //    1. 阻止程序的执行
      //    2. 把错误消息打印到控制台
      throw err
    }
    console.log(data)
    fs.readFile('./data/c.txt', 'utf8', function (err, data) {
      if (err) {
        // return console.log('读取失败')
        // 抛出异常
        //    1. 阻止程序的执行
        //    2. 把错误消息打印到控制台
        throw err
      }
      console.log(data)
    })
  })
})

输出是先输出a.txt -->b.txt -->c.txt

同级则看谁内存少就先输出谁 异步过程


```

为了解决以上编码方式带来的问题（回调地域嵌套），所以在ecmascript 6中新增了一个API `Promise`

promise 本身不是异步，但是内部是异步，气三种状态

Pending     resolve  reject

```javascript
var fs = require('fs')

var p1 = new Promise(function (resolve, reject) {
  fs.readFile('./data/a.txt', 'utf8', function (err, data) {
    if (err) {
      reject(err)
    } else {
      resolve(data)
    }
  })
})

var p2 = new Promise(function (resolve, reject) {
  fs.readFile('./data/b.txt', 'utf8', function (err, data) {
    if (err) {
      reject(err)
    } else {
      resolve(data)
    }
  })
})

var p3 = new Promise(function (resolve, reject) {
  fs.readFile('./data/c.txt', 'utf8', function (err, data) {
    if (err) {
      reject(err)
    } else {
      resolve(data)
    }
  })
})
----------------------------------------
    
p1
  .then(function (data) {
    console.log(data)
    // 当 p1 读取成功的时候
    // 当前函数中 return 的结果就可以在后面的 then 中 function 接收到
    // 当你 return 123 后面就接收到 123
    //      return 'hello' 后面就接收到 'hello'
    //      没有 return 后面收到的就是 undefined
    // 上面那些 return 的数据没什么卵用
    // 真正有用的是：我们可以 return 一个 Promise 对象
    // 当 return 一个 Promise 对象的时候，后续的 then 中的 方法的第一个参数会作为 p2 的 resolve
    // 
    return p2
  }, function (err) {
    console.log('读取文件失败了', err)
  })
  .then(function (data) {
    console.log(data)
    return p3
  })
  .then(function (data) {
    console.log(data)
    console.log('end')
  })

```

## 8.Node 中的其他成员

在每个模块中，除了`reqire` `exports` 等模块相关API之外，还有两个特殊的成员。

+ `__dirname`  **动态获取** 可以用来获取当前文件模块所属目录的绝对路径
+ `__filename` **动态获取** 可以用来获取当前文件的绝对路径

```javascript
// 路径为：F:\！！！！所有课件\13nodejs\nodejs资料（7天）\06\code\indx.html
__dirname 获取的是F:\！！！！所有课件\13nodejs\nodejs资料（7天）\06\code
__filename 获取的是：F:\！！！！所有课件\13nodejs\nodejs资料（7天）\06\code\indx.html
path.join(__dirname, './public/')
```

在文件操作中，仕勇相对路径是不可靠的，应为在Node中文件操作路径被设计为相对于执行node命令所处路径

## 9. 中间件

中间件的本质就是一个请求处理方法，我们把用户从请求到响应的整个过程分发到多个中间中去处理，目的是提高代码的灵活性，动态可扩展。

---------------------------`自来水厂处理水的过程`-----------------

