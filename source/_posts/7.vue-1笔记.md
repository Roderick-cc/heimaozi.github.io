---
title: VUE note
date: 2018-07-18 16:31:01
comments: true
reward: true
toc: true
tags:
	- Vue
	- note
---



# vue

<!-- more-->

## 1.1. 简单的模拟单页面应用程序效果

+ `hash`   网页内部定位
+ `window.onhashchange` 事件
+ 当 hash改变的时候，根据不同的hash做不同的处理

## 2.Vue.js

[官方文档](www.cn.vuejs.org)



## 3.起步

文本插值

绑定元素属性    v-bind：

判断if： v-if

循环： v-for

绑定事件： v-on:事件名称="事件处理函数"

表单与应用状态的双向绑定： v-model

### 3.1 数据绑定渲染-单向数据绑定

+ 文本绑定： 

+ 属性绑定： `v-bind：属性=“属性值”`   简写 `：属性=“属性值”`

  数据绑定：

  ```html
  <!--date 中的成员 message-->
  <h1>{{message}}</h1>

  <!--字符串 message-->
  <h1>{{'message'}}</h1>

  <!--错误用法-->
  <h1 foo='{{message}}' > 测试文本</h1>

  <!--绑定data 中的成员 message，正确的用法，也是响应式的 -->
  <h1 v-bind:foo='message'>测试文本</h1>
  ```


  ```

  使用JavaScript表达式：

  
  {{ number + 1}}
  {{ ok ？ 'YES' : "no"}}
  {{ messages.split('').reverse().join('')}}
  <div v-bind:id="'list-'id"></divdiv>
  ```

  ​

  ### 3.2 表单双向数据绑定

  + 文本

  + 多行文本

  + 复选框

  + 单选按钮

  + 选择列表

    ```html
    <!-- 确实能绑定data中的数据，但是不是双向的-->
    <input type="text" v-bind:value="message">
    <!-- 双向数据绑定-->
    <input type="text" v-model='message'>
    ```

    ​

  ### 3.3 事件处理

  Vue中methods 函数.

date  与methods  两者不能有重名

  ```html
<button v-on:click="handle">click me <button>
  
  ```

  简写

```html
@时间名称=“事件处理函数”
<button @click="handle">click me <button>
```

### 3.4 条件渲染和循环渲染

`v-if`

`v-for="item in fruits"`  

当需要按条件控制渲染多个元素的时候，可以把他们都放到template这个节点标签上，Vue会识别它，在渲染的结果中不包含template这个节点

### 3.5 watch 监视和计算属性

计算属性用于需要在模板中绑定输出值

而watch 观察者则用于需要根据数据的改变从而定制特殊业务

​	watch只是监视，不返回数据，而且只能观察自己的打他成员

​	

```javascript
watch:{
  监视实例：function （val，oldVal）{console.log(val,oldVal)}
}
//val 变化之前的数据
//oldVal 变化之后的数据

数据持久化 -->字符串
JSON.stringif()
JSON.parse()
window.localStorage.setItem()
```



## 4.ECMAScript 6

[ES6](es6.ruanfifeng.com)

## 5. 模板语法

数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：

```javascript	
<span>Message: {{ msg }}</span>
```

Vue数据具有双向绑定的特性，当绑定的数据对象发生改变是，插值出的内容也将会更新，通过使用 [v-once 指令](https://cn.vuejs.org/v2/api/#v-once)，你也能执行一次性地插值

```javascript
<span v-once>这个将不会改变: {{ msg }}</span>
```

### [原始 HTML](https://cn.vuejs.org/v2/guide/syntax.html#%E5%8E%9F%E5%A7%8B-HTML)

双大括号会将数据解释为普通文本，而非 HTML 代码,so

```html
<p>Using mustaches: {{ rawHtml }}</p>    // <span style="color: red">This should be red.</span> vue实例中数据为字符串，而视图中将解析为HTML
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```

## 6.计算属性和侦听器

## 7.Class 与Style绑定

### 7.1 Class

表达式结果的类型除了字符串之外，还可以是对象或数组。

对象语法

```html
我们可以传给 v-bind:class 一个对象，以动态地切换 class：
<div class="static"
     v-bind:class="{ active: isActive, 'text-danger': hasError }">
</div>
和如下 data：
data: {
  isActive: true,
  hasError: false
}
结果渲染为：

<div class="static active"></div>
```

数组语法:我们可以把一个数组传给 `v-bind:class`，以应用一个 class 列表：

```html
<div v-bind:class="[activeClass, errorClass]"></div>
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
渲染为：
<div class="active text-danger"></div>
如果你也想根据条件切换列表中的 class，可以用三元表达式：
<div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
```

### 7.2 style

`v-bind:style` 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名：

```html
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>

data: {
  activeColor: 'red',
  fontSize: 30
}
在对象中使用
<div v-bind:style="styleObject"></div>
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}

```

 **自动增加前缀**当 `v-bind:style` 使用需要添加[浏览器引擎前缀](https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix)的 CSS 属性时，如 `transform`，Vue.js 会自动侦测并添加相应的前缀。

## 8.条件渲染

### 8.1<template> 元素上使用 v-if 条件渲染分组

因为 `v-if` 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 `<template>` 元素当做不可见的包裹元素，并在上面使用 `v-if`。**最终的渲染结果将不包含 `<template>` 元素。**

```html
<template v-if="ok">
  <h1>Title</h1>
</template>
```

### v-else

`指令来表示 `v-if` 的“else 块”：

```html
<div v-if="Math.random() > 0.5">
  Now you see me
</div>
<div v-else>
  Now you don't
</div>
```

`v-else` 元素必须紧跟在带 `v-if` 或者 `v-else-if` 的元素的后面，否则它将不会被识别。

### key

表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` 属性即可

```html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

## 

## 9. 列表循环

我们用 `v-for` 指令根据一组数组的选项列表进行渲染。`v-for` 指令需要使用 `item in items` 形式的特殊语法，`items` 是源数据数组并且 `item` 是数组元素迭代的别名。

```
<ul id="example-1">
  <li v-for="item in items">
    {{ item.message }}
  </li>
</ul>

var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

`v-for` 还支持一个可选的第二个参数为当前项的索引。

```html
<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>
var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})
```

## 10.组件

+ 目前主流的前端框架都是使用用组件化开发思想

+ 组件就是对局部视图的封装

  + html结构

  + css样式

  + JavaScript 行为

    + data数据

    + methods 行为

      ​

### 10.1 使用组件

#### 10.1.1 全局注册

> 一般把网页中特殊的公共部分注册为全局组件：轮播图、tab选项卡、分页、通用导航等

注册

```javascript
Vue.component('组件名称'，{
      template："",
       data:function (){}
     })
```

使用：

```javascript
<div id="app">
  	<组件名称></组件名称>
 </div> 
```

#### 10.1.2 局部注册（子组件）

> 局部注册一般是注册一些非通用的，只使用与当前项目

#### 10.1.3 data 必须是函数

> 组件可以理解为特殊的Vue实例，管理自己的`template`模板
>
> + 组件的template必须只有一个根节点
> + 组件与组件之间是相互独立的，可以有自己的data methods computed
> + 组件的data必须是函数
> + 默认情况下，组件之间无法进行垮组件数据访问，父子组件也不行

```javascript
统一注册.js
new Vue({
  el:"#xxx",
  data:{},
  components:{
    //组件名称，组件名称
    appnavbar,appaside,Home
  }
})

//--------------------------
组件名称.js
;(function (){
  const template = `
//code
`
window.appnavbar ={
  template,
  data:function(){}
}

})()
```





#### 10.1.4 父子组件通信：Props Down

#### 10.1.5 父子组件通信 ：Events Up

#### 10.1.6 使用插槽分发组件内容

#### 10.1.7 动态组件



## 11. 服务端通信

+ Vue没有内置任何ajax请求方法
+ 在Vue1.0时代，使用插件，`VUe resource`发送请求
+ Vue2.0时代，`axios`迭代而出
+ H5 时代浏览器增加了一个特殊的异步清清方法`fetch`(原生支持promise)
+ 结合生命钩子获取数据，渲染数据

## 12. 自定义指令 全局与局部  生命周期

> 操作DOM的时候

在Vue中不要出现直接操作DOM的方式，如果想要操作DOM，就封装一个自定义指令，然后把这个指令作痛到你想要操作的这个DOM节点上

+ 注册绑定方式

  + 指令的名字：定义的时候不要加`v-`（只有使用的时候才加）

  + 使用驼峰命名的指令，要转为小写，用`-`短横杠拼接起来

  + 全局注册

    + `Vue.directive('指令名称'，{配置参数})`

    + 如果是全局指令，在一定要在实例化Vue之前注册

    + 全局指令在所有组件（实例）中都可以使用

   + 局部注册
    + 同构实例选项`directive`来注册

```javascript


<script>
  //-------------全局指令------
  Vue.directive('指令名称'，function（）{})
  //---------------------------
  new Vue({
  el:'#app',
  data:{},
  //------------局部指令-------------
  directive:{
    '指令名称'：function(){}
  }
  //-----------------------------
})
 </script>

```

生命周期

```javascript
<div id="app"><h1>{{message}}</h1></div>
<script src="node_modules/vue/dist/vue.js"></script>
<script>
	 var app= new Vue({
	el:"#app",
	data:{
		message:"hellow vue"
	},
	beforeCreate(){
		//实例初始化拿不到el data
		console.log('beforeCreate',this.$el,this.$data)
	},
	created(){
		//只是加载到data ，视图被没有渲染 拿不到el 还是{{message}}
		console.log('create',this.$el,this.$data)
	},
	beforeMount(){
		//加载并渲染到视图 {{hello vue}}
		console.log('beforeMount',this.$el,this.data)
	},

	beforeUpdate(){
		//能拿到更新修改前的DOM模板数据
		console.log('beforeMount',this.$el.innerHTML,this.data)
	},
	updated(){
		//被Vue更新修改渲染之后的DOM数据模板
		console.log('updata',this.$el.innerHTML,this.data)
	},
	activated(){

	}

})//.$mount('#app') 表意性


	 //app.$destory(0)    销毁实例
</script>
	
```



# view知识点

object.defineProperty 定义属性

给对象增加定义属性

```javascript
方法
var user{
  foo:"bar"  //第一种
}
use,age=18 // 第二种
use["name"]="jack"

// 对象 属性名  属性值
Object.defineProperty(user,'gender,{
                      //value:'男'
                      //get方法被用于属性访问
                      //当你访问genderde 时候，会自动调用get方法
                      get:function(){
  							return 123
						}
					//属性set 设置器
					//当你去uer.geder=XXX的时候，则会自动调用set方法，XXX将作为set方法的参数
//Vue计算属性 底层原理 理解即可
					set:function(value){}
                      })
                      
弹出浏览器红色的error
throw new Error（"invalid"）

```



# 总结：

- 计算属性

  + 一种特殊的属性，本质是方法，但是经过处理只能当做属性来使用
  + EcmaScript 5 :Object.defineProperty
  + 计算属性依赖数据进行缓存
  + 和方法相比，推荐使用计算属性
- 模板中也可以调用函数，使用函数的返回值作为渲染结果
  - 方法没有缓存
  - 每次使用都要重新调用
  - 方法所在的视图一旦有变化，则方法重新执行
- Object.defineProperty
  - get
  - set
- v-if 和v-for 条件循环渲染



# 外件操作json来模拟数据接口

## 使用`json-server`模拟

参考官方文档git上search ： json-server

> 安装 ： npm i -g json-server

使用

> 创建data.json 文件

启动接口服务（该服务默认占用3000端口）

> json-sercer --watch db.json

增删改查

+ GET/list 查询所有

+ GET/list/id 查询单个

  ​

## 接口测试工具：postman

## http-server

> 安装: npm install http-server -g 
>
> 查看帮助： hs -h

```javascript
//默认占用8080端口启动一个服务器，自动直接打开浏览器
hs -o
// 指定占用端口开启服务区
hs -o -p 3001
//不启用缓存开启
hs -c-l -p 3001 -o
```



- 文件夹中开启服务器命令 `hs -o -p 8088 `

