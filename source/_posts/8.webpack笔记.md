---
title: webpack note
date: 2018-07-20 16:31:01
comments: true
reward: true
toc: true
tags:
	- webpack
	- note
---





## webpack

<!-- more-->

安装

```shell
npm install -g webpack

//本地安装注意事项
npm install --save-dev webpack
对于安装到项目中的webpack需要配置 npm 的package.json 才能打包成功
script:{"build":"webpack"}


//npm环境中 打包执行
npm run build
```



```shell

```

为了划分目录结构的清晰

+ 把源码放在scr目录中
+ 打包的结果放在dist 目录中



### 配置文件：webpack.config.js

最基本的配置项

```javascript
const path = require('path');
module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};
```

```shell
//开放
export default function（）{} 
//导入
import XXX for "./path"
```

配置npm  package.json

```shell
"scripts": {
    "build" : "webpack"
  //  "watch-build":"webpack --watch" 监视build，其改变是自动重新执行,执行命令：webpack --watch
    
  },
```

执行打包

```shell
npm run build
```



### Ecmascript 6 模块规范

导入 import （require）

导出 export   （module.exports）

导出默认的成员：（只能有一个）

```shell
exports default 成员
```

加载默认成员

```shell
import XXX form '模块标识或路径'
```

导出多个成员：

```shell
//必须应用内部的一个成员
export const a=123
export const b=456
export function fn({console.log('fn')}

！！按需求加载指定的多个成员：
import {a,b} form '模块标识路径'

！！一次性加载所有导出成员
import * as XXX form '模块标识或路径'
```

### loading css

安装

```shell
# css-loader 的作用是把css文件转为JavaScript模块
#style-loader 的作用是动态创建style节点插入head中
npm install --save-dev style-loader
npm install --save-dev css-loader
```

配置

```shell
var path =require('path')
module.exports={
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  },
   module: {
    rules: [
      { test: /\.css$/, use: 'css-loader','style-loader' },
      { test: /\.ts$/, use: 'ts-loader' }
    ]
  }
}
```

### loading image

安装

```shell
npm instaa --save-dev file-loader
```



配置



### HtmlWebpackPlugin

打包结束，index.ttml在跟目录直接运行，图片资源的路径就无法访问到

解决办法：插件`html-webpack-plugin`

安装

```shell
npm install --save-dev html-webpack-plugin
```

配置

```shell
  const path = require('path');
+ const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js'
    },
  	 plugins: [
 	    new HtmlWebpackPlugin({
   	    title: 'Output Management'
      })
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist')
    }
  };
```

### 打包过程自动打包完毕自动刷新浏览器

webpack-dev-server

### bable:es6 ->es5

#### babel-polyfill

配置babel-plofill 来提供低版本浏览器中不支持的API

安装： npm i -d babel-polyfill

配置：使用在入口中写成函数

```shell
module.exports={
  entry:['bable-polyfill','./src/main.js']
}
```

#### transform-runtime解决代码重复问题

在打包过程中，babel 会在某些包提供一些工具函数，而这些工具函数可能会重复出现存在的模块，导致打包文件过大

安装

```shell
npm install babel-plugin-transform-runtime --save-dev
也可以
npm install babel-runtime --save
把 babel-runtime 安装为一个依赖。
```

配置



### Vue Loader--打包vue单文件组件

安装

```shell
两个第三方page
npm i -D vue-loader vue-template-compiler
```



组件热更新

### Externals

> 配置webpack 不打包第三方包

通常情况写不打包第三方包，因为第三方包大，和bundle打包到一起会造成资源体积过大，所以还是通过script标签的方式把第三方资源引入页面

在index.html页面引入资源

```shell
idnex.html
<script src="../node_modules/vue/dis/vue.js"></script>
```



```shell
webpack.config.js
使用第三方包的时候webpack会将第三方包嵌入到打包文件中，
externals:{
 //包名：全局的导出借口
  jquery:'jQuery', //'$'
  vue:'Vue'
}
```

```shell
main.js
import $ form 'jquer'
import vue form 'vue'
```





+ vue-loader
+ vue-template-compiler
+ css-loader
+ file-loader


### `--save`和 `--save-dev`的区别

把开发工具相关的依赖信息保存到`devDependencies`选项中。把核心依赖（VUE）的依赖信息保存到`dependencies`选项中

开发依赖和核心依赖分离，开发依赖在打包结束上线就不需要了，最后项目上线，真正需要安装的是`dependencies`依赖项中的包

通过指令安装`dependencies`依赖项中的包

```shell
npm install --production
```

### sublime 自定义代码段

```shell
tools -->developer -->new snippet
```

```shell
<snippet>
	<content><![CDATA[
//自定义内容
]]></content>
	<tabTrigger>tss</tabTrigger> //快捷键
</snippet>

//命名  tss.sublime-snippet
//$1 光标
//${1:command} 提示内容
```





tss.sublime-snippet

$1

${1:command}



## webpack 4.0 之后需要注意的

webpack打包Vue单文件组件

-  Vue-loader在15.*之后的版本都是 vue-loader的使用都是需要伴生 VueLoaderPlugin的,

需要增加以下的语句

```shell
const VueLoaderPlugin = require('vue-loader/lib/plugin')
module.exports = {
  module: {
    rules: [
      // ... 其它规则
      {
        test: /\.vue$/,
        loader: 'vue-loader'
      }
    ]
  },
  plugins: [
    // 请确保引入这个插件！
    new VueLoaderPlugin()
  ]
}
```

## 走通项目

### 在模块化环境中使用Vue-router 走通路由

监听json

```shell
npm install -g json-server
使用：
$ json-server --watch db.json
```



# vue Router

## 1.起步

>npm install vue 
>
>npm install router

```javascript	
// 1. 定义 (路由) 组件。
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }
// 2. 定义路由
const router=[
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]
// 3. 创建 router 实例，然后传 `routes` 配置
const router = new VueRouter({
  routes // (缩写) 相当于 routes: routes
})

// 4. 创建和挂载根实例。
const app = new Vue({
  router
}).$mount('#app')
```

## 2.动态路由匹配

```javascript
const router =new VueRouter({
  routes:[
    {
    	path: 'user/:id', //动态路径参数 一冒号开头
   		component: user
    }
  ]
})
```

参数值会被设置到`this.$route.params`,反之亦可通过此获得动态路径参数：id

除了 `$route.params` 外，`$route` 对象还提供了其它有用的信息。[参考文档][https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1] 

route 当前的路由   ------router 路由器

# 父子间组件数据通信

### 父组件给子组件传递数据通过props来传递：

​	1.现在父组件中往子组件标签上来增加属性的方式

​	2.然后再子组件中声明props来接受父组件传递过来的数据

​	3.然后再子组件中就可以直接通过this来访问props中的数据

### props单向绑定，单向数据流：

父组件的属性变化，将传到给子组件，但是子组件将数据修改将不会改变父组件的状态

，每次父组件更新时，子组件的所有props都会更新为最新值。

如果只取父组件的数据，而不受父组件的影响，并且自己还能修改

```javascript
props: ['ininialCounter'],
  data:function (){
    return {counter:this.initialCounter}
  }
```

