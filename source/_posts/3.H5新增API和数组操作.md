---
title: H5和ES6数组操作
date: 2018-06-04 09:43:01
comments: true
reward: true
toc: true
tags:
	- H5
	- Array
	- note
---



### 

<!--more-->

##### 1.获取元素

```javascript
document.getElementsByClassName ('class'); 
//通过类名获取元素，以伪数组形式存在。

document.querySelector('selector');
//通过CSS选择器获取元素，符合匹配条件的第1个元素。

document.querySelectorAll('selector'); 
//通过CSS选择器获取元素，以伪数组形式存在。
```

##### 2.类名操作



```javascript
Node.classList.add('class'); 
//添加class

Node.classList.remove('class'); 
//移除class

Node.classList.toggle('class'); 
//切换class，有则移除，无则添加

Node.classList.contains('class'); 
//检测是否存在class
```

##### 自定义属性

> 在HTML5中我们可以自定义属性，其格式如下data-*=""

```html
<div id="demo" data-my-name="itcast" data-age="10">
<script>
/*
  Node.dataset是以对象形式存在的，当我们为同一个DOM节点指定了多个自定义属性时，
  Node.dataset则存储了所有的自定义属性的值。
  */
var demo = document.querySelector(反馈);
//获取
//注：当我们如下格式设置时，则需要以驼峰格式才能正确获取
var name = demo.dataset['myName'];
var age = demo.dataset['age'];
//设置
demo.dataset['name'] = 'web developer';
<script/>
```

### H5-新增API

##### 全屏方法

> HTML5规范允许用户自定义网页上任一元素全屏显示。

- Node.requestFullScreen() 开启全屏显示
- Node.cancelFullScreen() 关闭全屏显示
- 由于其兼容性原因，不同浏览器需要添加前缀如：
  webkit内核浏览器：webkitRequestFullScreen、webkitCancelFullScreen，如chrome浏览器。
  Gecko内核浏览器：mozRequestFullScreen、mozCancelFullScreen，如火狐浏览器。
- document.fullScreen检测当前是否处于全屏
  不同浏览器需要添加前缀
  document.webkitIsFullScreen、document.mozFullScreen

##### 多媒体

> 自定义播放器

方法

| 方法             | 描述                   |
| -------------- | -------------------- |
| addTextTrack() | 向音频/视频添加新的文本轨道       |
| canPlayType()  | 检测浏览器是否能播放指定的音频/视频类型 |
| load()         | 重新加载音频/视频元素          |
| play()         | 开始播放音频/视频            |
| pause()        | 暂停当前播放的音频/视频         |

属性

| 属性                  | 描述                                   |
| ------------------- | ------------------------------------ |
| audioTracks         | 返回表示可用音轨的 AudioTrackList 对象          |
| autoplay            | 设置或返回是否在加载完成后随即播放音频/视频               |
| buffered            | 返回表示音频/视频已缓冲部分的 TimeRanges 对象        |
| controller          | 返回表示音频/视频当前媒体控制器的 MediaController 对象 |
| controls            | 设置或返回音频/视频是否显示控件（比如播放/暂停等）           |
| crossOrigin         | 设置或返回音频/视频的 CORS 设置                  |
| currentSrc          | 返回当前音频/视频的 URL                       |
| currentTime         | 设置或返回音频/视频中的当前播放位置（以秒计）              |
| defaultMuted        | 设置或返回音频/视频默认是否静音                     |
| defaultPlaybackRate | 设置或返回音频/视频的默认播放速度                    |
| duration            | 返回当前音频/视频的长度（以秒计）                    |
| ended               | 返回音频/视频的播放是否已结束                      |
| error               | 返回表示音频/视频错误状态的 MediaError 对象         |
| loop                | 设置或返回音频/视频是否应在结束时重新播放                |
| mediaGroup          | 设置或返回音频/视频所属的组合（用于连接多个音频/视频元素）       |
| muted               | 设置或返回音频/视频是否静音                       |
| networkState        | 返回音频/视频的当前网络状态                       |
| paused              | 设置或返回音频/视频是否暂停                       |
| playbackRate        | 设置或返回音频/视频播放的速度                      |
| played              | 返回表示音频/视频已播放部分的 TimeRanges 对象        |
| preload             | 设置或返回音频/视频是否应该在页面加载后进行加载             |
| readyState          | 返回音频/视频当前的就绪状态                       |
| seekable            | 返回表示音频/视频可寻址部分的 TimeRanges 对象        |
| seeking             | 返回用户是否正在音频/视频中进行查找                   |
| src                 | 设置或返回音频/视频元素的当前来源                    |
| startDate           | 返回表示当前时间偏移的 Date 对象                  |
| textTracks          | 返回表示可用文本轨道的 TextTrackList 对象         |
| videoTracks         | 返回表示可用视频轨道的 VideoTrackList 对象        |
| volume              | 设置或返回音频/视频的音量                        |

事件

| 事件             | 描述                     |
| -------------- | ---------------------- |
| abort          | 当音频/视频的加载已放弃时          |
| canplay        | 当浏览器可以播放音频/视频时         |
| canplaythrough | 当浏览器可在不因缓冲而停顿的情况下进行播放时 |
| durationchange | 当音频/视频的时长已更改时          |
| emptied        | 当目前的播放列表为空时            |
| ended          | 当目前的播放列表已结束时           |
| error          | 当在音频/视频加载期间发生错误时       |
| loadeddata     | 当浏览器已加载音频/视频的当前帧时      |
| loadedmetadata | 当浏览器已加载音频/视频的元数据时      |
| loadstart      | 当浏览器开始查找音频/视频时         |
| pause          | 当音频/视频已暂停时             |
| play           | 当音频/视频已开始或不再暂停时        |
| playing        | 当音频/视频在已因缓冲而暂停或停止后已就绪时 |
| progress       | 当浏览器正在下载音频/视频时         |
| ratechange     | 当音频/视频的播放速度已更改时        |
| seeked         | 当用户已移动/跳跃到音频/视频中的新位置时  |
| seeking        | 当用户开始移动/跳跃到音频/视频中的新位置时 |
| stalled        | 当浏览器尝试获取媒体数据，但数据不可用时   |
| suspend        | 当浏览器刻意不获取媒体数据时         |
| timeupdate     | 当目前的播放位置已更改时           |
| volumechange   | 当音量已更改时                |
| waiting        | 当视频由于需要缓冲下一帧而停止        |

##### 地理定位

> 在HTML规范中，增加了获取用户地理信息的API，
> 这样使得我们可以基于用户位置开发互联网应用，
> 即基于位置服务 (Location Base Service)

- 获取当前地理信息

```
navigator.geolocation.getCurrentPosition(successCallback, errorCallback) 
```

- 重复获取当前地理信息

```
navigator. geolocation.watchPosition(successCallback, errorCallback)
```

- 当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position。
  position.coords.latitude纬度
  position.coords.longitude经度
  position.coords.accuracy精度
  position.coords.altitude海拔高度
- 当获取地理信息失败后，会调用errorCallback，并返回错误信息error
- 在现实开发中，通过调用第三方API（如百度地图）来实现地理定位信息，这些API都是基于用户当前位置的，并将用位置位置（经/纬度）当做参数传递，就可以实现相应的功能。

##### 本地存储

> 随着互联网的快速发展，基于网页的应用越来越普遍，
> 同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，
> HTML5规范提出了相关解决方案。

- 特性
  - 设置、读取方便
  - 容量较大，sessionStorage约5M、
  - localStorage约20M
  - 只能存储字符串，可以将对象JSON.stringify() 编码后存储
- window.sessionStorage
  - 生命周期为关闭浏览器窗口
  - 在同一个窗口(页面)下数据可以共享
- window.localStorage
  - 永久生效，除非手动删除（服务器方式访问然后清除缓存）
  - 可以多窗口（页面）共享
- 方法
  - setItem(key, value) 设置存储内容
  - getItem(key) 读取存储内容
  - removeItem(key) 删除键值为key的存储内容
  - clear() 清空所有存储内容

##### 历史管理

> 提供window.history，对象我们可以管理历史记录，
> 可用于单页面应用，Single Page Application，可以无刷新改变网页内容。

- pushState(data, title, url) 追加一条历史记录  

  - data用于存储自定义数据，通常设为null

    - title网页标题，基本上没有被支持，一般设为空

    ​+ url 以当前域为基础增加一条历史记录，不可跨域设置

- replaceState(data, title, url) 与pushState()基本相同，
  不同之处在于replaceState()，只是替换当前url，不会增加/减少历史记录。

- onpopstate事件，当前进或后退时则触发  

##### 离线应用

> HTML5中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个cache manifest文件。

- 优势
  - 1、可配置需要缓存的资源
  - 2、网络无连接应用仍可用
  - 3、本地读取缓存资源，提升访问速度，增强用户体验
  - 4、减少请求，缓解服务器负担
- 缓存清单
  - 一个普通文本文件，其中列出了浏览器应缓存以供离线访问的资源，推荐使用.appcache为后缀名
  - 例如我们创建了一个名为demo.appcache的文件，然后在需要应用缓存在页面的根元素(html)添加属性manifest="demo.appcache"，路径要保证正确。
- manifest文件格式
  - 1、顶行写CACHE MANIFEST
  - 2、CACHE: 换行 指定我们需要缓存的静态资源，如.css、image、js等
  - 3、NETWORK: 换行 指定需要在线访问的资源，可使用通配符
  - 4、FALLBACK: 换行 当被缓存的文件找不到时的备用资源
- 其它
  - 1、CACHE: 可以省略，这种情况下将需要缓存的资源写在CACHE MANIFEST
  - 2、可以指定多个CACHE: NETWORK: FALLBACK:，无顺序限制
  - 3、#表示注释，只有当demo.appcache文件内容发生改变时或者手动清除缓存后，才会重新缓存。
  - 4、chrome 可以通过chrome://appcache-internals/工具和离线（offline）模式来调试管理应用缓存

##### 文件读取

> HTML5新增内建对象，可以读取本地文件内容。
>
> 在HTML表单中，可以上传文件的唯一控件就是`<input type="file">`。
>
> *注意*：当一个表单包含`<input type="file">`时，表单的`enctype`必须指定为`multipart/form-data`，`method`必须指定为`post`，浏览器才能正确编码并以`multipart/form-data`格式发送表单的数据。
>
> 出于安全考虑，浏览器只允许用户点击`<input type="file">`来选择本地文件，用JavaScript对`<input type="file">`的value`赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径

HTML5的File API提供了`File`和`FileReader`两个主要对象，可以获得文件信息并读取文件。

案例：

```
	<input type="file" class="file" multiple>
	<img src="" alt="" id="img">
	<script>
		/*获取到了文件表单元素*/
		var file = document.querySelector('.file');
		/*选择文件后触发*/
		file.onchange = function () {
			/*初始化了一个文件读取对象*/
			var reader = new FileReader();
			/*读取文件数据  this.files[0] 文件表单元素选择的第一个文件 */
			reader.readAsDataURL(this.files[0]);
			/*读取的过程就相当于 加载过程 */
			/*读取完毕  预览 */
			reader.onload = function () {
			    /*读取完毕 base64位数据  表示图片*/
			    console.log(this.result);
				document.querySelector('#img').src = this.result;
			}
		}
	</script>
```

上面的代码演示了如何通过H5的file API读取文件内容。DateURL的形式读取到的问见是一个字符串，类似

`data:image/png;base64,iVBORw0KGgoAAAA`，常，用于设置图像。如果需要服务器端处理，把字符串base64,后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。

JavaScript的一个重要特性就是单线程执行模式，关于H5 文件操作这里还有一个说明是廖雪峰写的关于异步实现的文件操作，有兴趣的可以看一下

[](https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449993875172bbfac4b9764e2d9e2b5a17c706b3db000)

##### 拖拽

事件

box.addEventListener('drag', function (e) {});

| drag      | 整个拖拽执行 |
| --------- | ------ |
| dragleave | 拖拽离开   |
| dragstart | 拖拽开始   |
| dragend   | 拖拽结束   |
| dragover  | 拖拽智商   |
| drop      | 拖拽松开   |



##### 网络状态

- 我们可以通过window.onLine来检测，用户当前的网络状况，返回一个布尔值
  - window.online用户网络连接时被调用
  - window.offline用户网络断开时被调用






## 一 数组的常用方法 --->Array 对象属性

### concat()

concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，仅会返回被连接数组的一个副本。

```javascript
var arr1 = [1,2,3];
var arr2 = [4,5];
var arr3 = arr1.concat(arr2);
console.log(arr1); 
//[1, 2, 3]console.log(arr3); 
//[1, 2, 3, 4, 5]
```

### join()

join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的，默认使用','号分割，不改变原数组。

```javascript
var arr = [2,3,4];
console.log(arr.join()); 
//2,3,4console.log(arr); 
//[2, 3, 4]
```

### push()

push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。末尾添加，返回的是长度，会改变原数组。

```javascript
var a = [2,3,4];
var b = a.push(5);
console.log(a); 
//[2,3,4,5]console.log(b); 
//4push方法可以一次添加多个元素push(data1,data2....)
```

### pop()

pop() 方法用于删除并返回数组的最后一个元素。返回最后一个元素，会改变原数组。

```javascript
var arr = [2,3,4];console.log(arr.pop()); //4console.log(arr);  //[2,3]
```

### shift()

shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。返回第一个元素，改变原数组。

```javascript
var arr = [2,3,4];console.log(arr.shift()); //2console.log(arr);  //[3,4]
```

### unshift()

unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。返回新长度，改变原数组。

```javascript
var arr = [2,3,4,5];
console.log(arr.unshift(3,6)); 
//6console.log(arr); 
//[3, 6, 2, 3, 4, 5]
tip:该方法可以不传参数,不传参数就是不增加元素。
```

### slice()

返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。返回选定的元素，该方法不会修改原数组。

```javascript
var arr = [2,3,4,5];
console.log(arr.slice(1,3)); 
//[3,4]console.log(arr); 
//[2,3,4,5]
```

### 、splice()

splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。splice() 方法会直接对数组进行修改。

```javascript
var a = [5,6,7,8];
console.log(a.splice(1,0,9));//[]
console.log(a); // [5, 9, 6, 7, 8]
var b = [5,6,7,8];
console.log(b.splice(1,2,3)); //[6, 7]
console.log(b);//[5, 3, 8]
```

### substring() 和 substr()

**相同点：**如果只是写一个参数，两者的作用都一样：都是是截取字符串从当前下标以后直到字符串最后的字符串片段。
substr(startIndex);
substring(startIndex);

```javascript
var str = '123456789';
console.log(str.substr(2));    //  "3456789"
console.log(str.substring(2)) ;//  "3456789"
```

**不同点：**第二个参数
substr（startIndex,lenth）： 第二个参数是截取字符串的长度（从起始点截取某个长度的字符串）；
substring（startIndex, endIndex）： 第二个参数是截取字符串最终的下标 （截取2个位置之间的字符串,‘含头不含尾’）。

```javascript
console.log("123456789".substr(2,5));    //  "34567"console.log("123456789".substring(2,5)) ;//  "345"
```

### sort 排序

按照 Unicode code 位置排序，默认升序

```javascript
var fruit = ['cherries', 'apples', 'bananas'];
fruit.sort(); // ['apples', 'bananas', 'cherries']
var scores = [1, 10, 21, 2];
scores.sort(); // [1, 10, 2, 21]
```

### reverse()

reverse() 方法用于颠倒数组中元素的顺序。返回的是颠倒后的数组，会改变原数组。

```javascript
var arr = [2,3,4];
console.log(arr.reverse()); //[4, 3, 2]
console.log(arr);  //[4, 3, 2]
```

### indexOf 和 lastIndexOf

都接受两个参数：查找的值、查找起始位置
不存在，返回 -1 ；存在，返回位置。indexOf 是从前往后查找， lastIndexOf 是从后往前查找。
**indexOf**

```javascript
var a = [2, 9, 9];
a.indexOf(2); // 0
a.indexOf(7); // -1
if (a.indexOf(7) === -1) {  
  // element doesn't exist in array
}
```

**lastIndexOf**

```javascript
var numbers = [2, 5, 9, 2];
numbers.lastIndexOf(2);     // 3
numbers.lastIndexOf(7);     // -1
numbers.lastIndexOf(2, 3);  // 3
numbers.lastIndexOf(2, 2);  // 0
numbers.lastIndexOf(2, -2); // 0
numbers.lastIndexOf(2, -1); // 3
```

### every

对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true

```javascript
function isBigEnough(element, index, array) { 
  return element < 10;
}    
[2, 5, 8, 3, 4].every(isBigEnough);   // true
```

### some

对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true

```javascript
function compare(element, index, array) {
  return element > 10;
}   
[2, 5, 8, 1, 4].some(compare);  // false
[12, 5, 8, 1, 4].some(compare); // true
```

### filter

对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组

```javascript
var words = ["spray", "limit", "elite", "exuberant", "destruction", "present", "happy"];
var longWords = words.filter(function(word){ 
  return word.length > 6;
});
// Filtered array longWords is ["exuberant", "destruction", "present"]
```

### map

对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组

```javascript
var numbers = [1, 5, 10, 15];
var doubles = numbers.map(function(x) {
  return x * 2;
});
// doubles is now [2, 10, 20, 30]
// numbers is still [1, 5, 10, 15]
```

### forEach 数组遍历

```javascript
const items = ['item1', 'item2', 'item3'];
const copy = [];  
items.forEach(function(item){ 
  copy.push(item)
});
```



## ES6新增新操作数组的方法

### find()：

传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。

```javascript
const arr = [1, "2", 3, 3, "2"]
console.log(arr.find(n => typeof n === "number")) // 1
```

### findIndex()：

传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。

```javascript
const arr = [1, "2", 3, 3, "2"]
console.log(arr.findIndex(n => typeof n === "number")) // 0
```

### fill()：

用新元素替换掉数组内的元素，可以指定替换下标范围。

```javascript
arr.fill(value, start, end)
```

### copyWithin()：

选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。

```javascript
arr.copyWithin(target, start, end)
const arr = [1, 2, 3, 4, 5]
console.log(arr.copyWithin(3)) 
// [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2const arr1 = [1, 2, 3, 4, 5]
console.log(arr1.copyWithin(3, 1)) 
// [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3
const arr2 = [1, 2, 3, 4, 5]
console.log(arr2.copyWithin(3, 1, 2)) 
// [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2
```

### from

将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组

```javascript
const bar = ["a", "b", "c"];
Array.from(bar);
// ["a", "b", "c"]
Array.from('foo');
// ["f", "o", "o"]
```

### of

用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。

```javascript
Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
Array.of(7);       // [7]
Array.of(1, 2, 3); // [1, 2, 3]
Array(7);          // [ , , , , , , ]
Array(1, 2, 3);    // [1, 2, 3]
```

### entries() 返回迭代器：返回键值对

```javascript
//数组
const arr = ['a', 'b', 'c']
;for(let v of arr.entries()) { 
  console.log(v)
}
// [0, 'a'] [1, 'b'] [2, 'c']
//Set
const arr = new Set(['a', 'b', 'c']);
for(let v of arr.entries()) { 
  console.log(v)
}
// ['a', 'a'] ['b', 'b'] ['c', 'c']
//Map
const arr = new Map();
arr.set('a', 'a');
arr.set('b', 'b');
for(let v of arr.entries()) { 
  console.log(v)
}
// ['a', 'a'] ['b', 'b']
```

### values() 返回迭代器：返回键值对的value

```javascript
//数组
const arr = ['a', 'b', 'c'];
for(let v of arr.values()) { 
  console.log(v)
}
//'a' 'b' 'c'
//Set
const arr = new Set(['a', 'b', 'c']);
for(let v of arr.values()) {
  console.log(v)
}
// 'a' 'b' 'c'
//Map
const arr = new Map();
arr.set('a', 'a');
arr.set('b', 'b');
for(let v of arr.values()) {
  console.log(v)
}
// 'a' 'b'
```

### keys() 返回迭代器：返回键值对的key

```javascript
//数组
const arr = ['a', 'b', 'c'];
for(let v of arr.keys()) {
  console.log(v)
}
// 0 1 2
//Set
const arr = new Set(['a', 'b', 'c']);
for(let v of arr.keys()) { 
  console.log(v)
}
// 'a' 'b' 'c'
//Map
const arr = new Map();
arr.set('a', 'a');
arr.set('b', 'b');
for(let v of arr.keys()) {  
  console.log(v)
}
// 'a' 'b'
```

### includes

判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。

```javascript
var a = [1, 2, 3];
a.includes(2); // true
a.includes(4); // false
```





## [关于更多的对象属性方法请点击此查看](http://www.runoob.com/jsref/jsref-obj-array.html)

